title: Institutional Grammar 2.0 JSON Schema, strict variant
description: >
  IG 2.0 schema (https://arxiv.org/abs/2008.08937) designed by students from the Faculty of
  Mathematics and Information Science of the Warsaw University of Technology.
  
  This schema is still a prototype and subject to unannounced change.
$id: http://www.example.org/ig-strict
$schema: http://json-schema.org/draft-06/schema#
$defs:
  # A logical operator with N operands
  LogicalOperator:
    type: string
    enum:
      - AND
      - OR
      - XOR

  # An abstract span of text.
  # The "begin" property is relative to text in the root of the document.
  TextSpan:
    type: object
    properties:
      text: { type: string }
      begin: { type: integer }
      length: { type: integer }
    # These are required for files exchanged between tools
    # For user display, begin and length may be omitted
    required:
      - text
      - begin
      - length

  # A simple text node in the tree
  SimpleNode:
    allOf: 
      - $ref: '#/$defs/TextSpan'
    additionalProperties: false
    properties:
      text: true
      begin: true
      length: true

  # Abstract base type for:
  #  - RegulativeStatement
  #  - ConstitutiveStatement
  #  - StatementCombination
  AbstractStatement:
    type: object
    allOf:
      - $ref: '#/$defs/TextSpan'
    properties:
      type:
        # This is required for Regulative- and ConstitutiveStatements
        type: string
        enum:
          - institutionalStatement
          - statementOfFact
      inversion:
        type: boolean
        default: false
      orElse: { $ref: '#/$defs/Statement' }

  # Any type of statement
  Statement:
    oneOf:
      - $ref: '#/$defs/RegulativeStatement'
      - $ref: '#/$defs/ConstitutiveStatement'
      - $ref: '#/$defs/StatementCombination'

  # Either a regulative institutional statement or statement of fact
  RegulativeStatement:
    additionalProperties: false
    allOf:
      - $ref: '#/$defs/AbstractStatement'
    properties:
      # We have to indicate that inherited properties are allowed, see
      # https://stackoverflow.com/a/58798563
      # Inherited from AbstractStatement
      type: true
      inversion: true
      orElse: true
      # Inherited from TextSpan
      text: true
      begin: true
      length: true
      attribute: { $ref: '#/$defs/ComponentWithProperties' }
      directObject: { $ref: '#/$defs/ComponentWithProperties' }
      indirectObject: { $ref: '#/$defs/ComponentWithProperties' }
      deontic: { $ref: '#/$defs/ComponentWithoutProperties' }
      aim: { $ref: '#/$defs/ComponentWithoutProperties' }
      activationCondition: { $ref: '#/$defs/ComponentWithoutProperties' }
      executionConstraint: { $ref: '#/$defs/ComponentWithoutProperties' }
    required:
      - type
      - attribute
      - aim

  # Either a constitutive institutional statement or statement of fact
  ConstitutiveStatement:
    additionalProperties: false
    allOf:
      - $ref: '#/$defs/AbstractStatement'
    properties:
      # Inherited from AbstractStatement
      type: true
      inversion: true
      orElse: true
      # Inherited from TextSpan
      text: true
      begin: true
      length: true
      constitutedEntity: { $ref: '#/$defs/ComponentWithProperties' }
      deontic: { $ref: '#/$defs/ComponentWithoutProperties' }
      constitutiveFunction: { $ref: '#/$defs/ComponentWithoutProperties' }
      constitutingProperty: { $ref: '#/$defs/ComponentWithProperties' }
      activationCondition: { $ref: '#/$defs/ComponentWithoutProperties' }
      executionConstraint: { $ref: '#/$defs/ComponentWithoutProperties' }
    required:
      - type
      - constitutedEntity
      - constitutiveFunction
  
  # Logical combination of statements
  StatementCombination:
    additionalProperties: false
    allOf:
      - $ref: '#/$defs/AbstractStatement'
    properties:
      # Inherited from AbstractStatement
      inversion: true
      orElse: true
      # Inherited from TextSpan
      text: true
      begin: true
      length: true
      logicalOperator: { $ref: '#/$defs/LogicalOperator' }
      statements:
        type: array
        items: { $ref: '#/$defs/Statement' }
        minItems: 2
    required:
      - logicalOperator
      - statements
      
  # Represents statement components that cannot have properties
  ComponentWithoutProperties:
    oneOf:
      - $ref: '#/$defs/SimpleNode' # simple node
      - $ref: '#/$defs/Statement' # nested statement
      - type: object # logical combination
        additionalProperties: false
        properties:
          logicalOperator: { $ref: '#/$defs/LogicalOperator' }
          components:
            type: array
            items: { $ref: '#/$defs/ComponentWithoutProperties' }
            minItems: 2
        required:
          - logicalOperator
          - components

  # Represents statement components that can have properties
  # Can be a:
  #   - simple node
  #   - node with properties
  #   - nested institutional statement
  #   - logical combination of the above
  ComponentWithProperties:
    oneOf:
      - $ref: '#/$defs/SimpleNode' # simple node
      - $ref: '#/$defs/Statement' # nested statement
      - $ref: '#/$defs/ComponentWithPropertiesCombination' # logical combination
      - type: object # node with loosely-attached properties
        additionalProperties: false
        properties:
          element: { $ref: '#/$defs/SimpleNode' }
          properties:
            type: array
            items: { $ref: '#/$defs/ComponentWithProperties' }
        required:
          - element
          - properties # if properties are not defined, just use a plain node

  # A logical combination of components with properties
  ComponentWithPropertiesCombination:
    type: object
    additionalProperties: false
    properties:
      logicalOperator: { $ref: '#/$defs/LogicalOperator' }
      components:
        type: array
        items: { $ref: '#/$defs/ComponentWithProperties' }
        minItems: 2
    required:
      - logicalOperator
      - components


# TODO: add metadata fields? Dublin Core maybe?
# Root element
type: object
properties:
  text: { type: string }
  statements:
    type: array
    items: { $ref: '#/$defs/Statement' }
additionalProperties: false
